# U is for update 

The next thing to do is update the items. We are going to make use of the checkboxes we drew.

When a user checks a box then the item should be marked as "complete" in the database. The user should also be able to uncheck boxes.

This sounds simple enough, but there are complexities. We need to be sure that when we check a box then the correct item is updated. And we need to make sure that the UI is accurate once the box is checked. 

## A first test 

Here is the algorithm for our first test:

```
add some items into the database using the model.objects.create method
use playwrite to check a box
check the database to make sure that the changes were saved to the database 
make sure that the box looks checked on the frontend 
```

Take some time to think through the problem before you look at the answer. How would you choose to check a specific box?

If we use the codegen to figure that out then we get some crazy looking code, for example:

```
page.locator("div:nth-child(3) > div > .h-6").check()
```

Yuck.

Playwright has a solution to these kinds of problems. An attribute called `data-testid`

Let's start off by making it easier to write our tests and access the elements we need to.

Go to the partial template and add a testid to the checkbox. Mine looks like this:

```
<input 
  type="checkbox" 
  class="h-6 w-6 rounded border-green-300 text-green-600 accent-green-400  cursor-pointer inline-block align-middle" 
  data-testid="toggle_item_{{ item.id }}" />
```

Note that the `testid` makes use of the item's database id. so every checkbox will have a unique `testid`.


Now if we use `playwright codegen` again, we can poke around and get some code that looks more like this:

```
page.get_by_test_id("toggle_item_4").check()
page.get_by_test_id("toggle_item_4").uncheck()
expect(page.get_by_test_id("toggle_item_4")).to_be_checked()
expect(page.get_by_test_id("toggle_item_5")).not_to_be_checked()
```

This is much easier to work with.

**COMMON PROBLEM** 

If your `playwright codegen` is still generating funny looking code at this point then it is probably because your html is not formatted correctly. It's really important to make sure that all your html attributes have open and close quotes in the right places. 

Eg, this will not work:

```
<input 
  type="checkbox" 
  class="h-6 w-6 rounded border-green-300 text-green-600 accent-green-400  cursor-pointer inline-block align-middle 
  data-testid="toggle_item_{{ item.id }}" />
```

And this one will render your checkboxes as text inputs:

```
<input 
  type="checkbox 
  class="h-6 w-6 rounded border-green-300 text-green-600 accent-green-400  cursor-pointer inline-block align-middle" 
  data-testid="toggle_item_{{ item.id }}" />
```

Every attribute must have an opening and closing `"`. 

## Final test

Here is a test:

```
def test_checkbox(live_server, page: Page):
    items = [models.TodoItem.objects.create(title=f"Test item {i}") for i in range(3)]
    page.goto(reverse_url(live_server, "index"))

    middle_item = items[1]
    middle_id = f"toggle_item_{middle_item.id}"
    page.get_by_test_id(middle_id).check()
    expect(page.get_by_test_id(middle_id)).to_be_checked()

    middle_item.refresh_from_db()
    assert middle_item.completed is True

    items[0].refresh_from_db()
    assert items[0].completed is False

    items[2].refresh_from_db()
    assert items[2].completed is False
```

Let's zoom in on this line for a moment:

```
items = [models.TodoItem.objects.create(title=f"Test item {i}") for i in range(3)]
```

This makes use of `models.TodoItem` so you will need to import something at the top of your test file to make this work. Otherwise you will get a `NameError`.

The other really cool thing about this line is that it uses `range`. If you are new to Python then it's worth taking some time to understand how `range` works. It comes up a lot.

The last thing to notice is that the line is sortof like a for loop. This is called a "list comprehension". These things are super powerful and worth knowing about!

## The code

Of course, the test will fail because we haven't implemented the code yet. 

Let's sort that out.

In the TODO list app, we'll want to send a PUT request to the backend when a box is checked. 

We'll need:

- A view that updates the item 
- A url that maps to the view 
- An event listener on the checkbox so that when it gets checked or unchecked, a request is sent to the backend 

## The view 

Since this is an update, we'll make use of a PUT request. We'll also need to accept the item_id as an input so that we know what we are updating.

```
@require_http_methods(["PUT"])
def action_toggle_todo(request, item_id):
    item = models.TodoItem.objects.get(id=item_id)
    item.completed = not item.completed
    item.save()
    return HttpResponse('') 
```

You will also need to import `HttpResponse` to get this to work.  Put this somewhere near the top of your views.py file:

```
from django.http import HttpResponse
```

Ok, so we are returning `HttpResponse('')`. This is a blank response.  What do you think will happen? We'll get to the answer in a little while.

## The Url

Add the following to the app's urls.py file:

```
path(
        "action_toggle_todo/<int:item_id>",
        views.action_toggle_todo,
        name="action_toggle_todo",
    ),
```

Notice that the url itself can contain parameters and wildcards. This let's us say what item we are referring to.

## The template 

Now let's update the partial template. We'll add an `hx-put` attribute to the checkbox:

```
hx-put="{% url 'action_toggle_todo' item.id %}"
```

## Something is wrong! 

In your browser, open up the dev tools and watch the requests that are getting fired off from your application. When you check a box you'll get a 403 error. That's a permission denied error.

This is happening because of a lack of CSRF token in the request. Remember how we added the token to the form as a hidden input? If you don't remember, go look closely at the `form` section of your `index.html` page.

`GET` requests do not need a CSRF token. `POST`, `PUT` and `DELETE` requests do. 

Go to your `index.html` file and add an attribute to your body tag. It should look like this:

```
<body hx-headers='{"X-CSRFToken": "{{ csrf_token }}"}'>
```

Now try again. The permission error is gone. And the tests all pass.

What do you think will happen if we remove the `{% csrf_token %}` hidden input from the `<form>`? Will it still work?

Go find out. You can find out by deleting it and running your tests.

## Using TDD to squash bugs 

There is a bug! Can you see it?

A really great way to fight bugs and prevent regressions is to write a test that exposes the bug and then make the test pass. 

Our bug becomes obvious if we check some boxes and then refresh the page. All the checkboxes remain unchecked! 

## Writing a test 

The test should:

1. Add an item to the database and make sure it is marked as complete
2. Open up the page and make sure that the checkbox is checked

Again, think though it before looking at the answer

```
def test_checkbox_loads_correctly(live_server, page: Page):
    item = models.TodoItem.objects.create(title="Test item", completed=True)
    page.goto(reverse_url(live_server, "index"))
    checkbox_id = f"toggle_item_{item.id}"
    expect(page.get_by_test_id(checkbox_id)).to_be_checked()
```

Now, to make the test pass, we update the partial template. The checkbox should now look like this:

```
<input 
    type="checkbox" 
    class="nice things" 
    data-testid="toggle_item_{{ item.id }}" 
    {% if item.completed %} checked {% endif %}
    hx-put="{% url 'action_toggle_todo' item.id %}" />

```

If you get weird template rendering errors it can be because of an autoformatter messing up your template tags. 

Run your tests again, they should pass!

## Pay close attention 

You will need to use test ids in the next section. You'll need to understand them really well. This is critical information.

Spend some time experimenting with your code. What happens if you use an `id` instead of a `data-testid`? What if you try to refer to a `data-testid` that doesn't exist? Can you use playwright to fetch an item by `id`? Or only `data-testid`? 

What kinds of errors do your tests give you when you mess around? Pay attention to the error messages.

Spend some time poking around and experimenting. 